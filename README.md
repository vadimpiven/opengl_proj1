# Вращающийся цветовой конус в OpenGl
Для использования данного кода необходимо его клонировать, поскольку библиотеки подключены через
`git submodule`, а значит простое скачивание архива с Github даст код без библиотек, в результате чего он не
будет собираться. Клонировать проект можно через командрую строку командой
```
git clone --recursive https://github.com/vadimpiven/opengl_proj1
```
или, если используется Visual Studio 2019 - достаточно вставить ссылку на этот репозиторий в строку
"клонировать" на экране приветствия
([подробная инструкция](https://docs.microsoft.com/ru-ru/visualstudio/get-started/tutorial-open-project-from-repo?view=vs-2019)).

## Источники
Проект в основном разрабатывался на основе уроков, приведённых в [данной серии статей](https://habr.com/ru/post/310790/).
Проект в основном находится в рамках уроков 1.1-1.9 за некоторыми исключениями. Для понимания происходящего
настоятельно рекоммендуется изучить хотя бы уроки 1.1 (общие сведения об OpenGL) и 1.4 (отрисовка одного полигона).

## Общая структура
OpenGL является открытым стандартом, описывающим функциональность, которую должны предоставлять видеоадаптеры.
Поэтому OpenGL это не какая-то единая кроссплатформенная библиотека, о множество отдельных реализаций,
вшитых в драйверы видеоадаптеров их производителем. Его единственная задача - вычислять цвет пикселей двумерного буфера.
Таким образом, для работы с OpenGL требуется несколько дополнительных библиотек:
- требуется средствами операционной системы создавать окно программы, в котором далее будет отрисовываться буфер с вычисленными OpenGl цветами,
в данной реализации для этих целей используется библиотека GLFW
- требуется запросить разрешение на использование определённого функционала OpenGL и получить адреса функций в драйвере видеоадаптера,
в данной реализации для этих целей используется библиотека GLEW
- для удобства работы с OpenGL используется библиотека GLM, позволяющая строить матрицы, которые затем передаются
в память видеокарты и используются для вычисления точного цвета пикселей в соответствии с построенной 3D сценой
- для использования текстур используется библиотека STB, позволяющая считывать с диска изображения распространённых форматов
- для загрузки 3D моделей в формате `.obj` к проекту подключена, но не использована, библиотека TinyObjLoader
Все библиотеки подключены статически для избежания проблем с переносимостью проекта.

## Cmake
Для сборки данного проекта используется система сборки Cmake. Она позволяет сделать процесс сборки платформонезависимым.

### Используемые команды Cmake
- `cmake_minimum_required(VERSION 3.8)` - устанавливает минимальную версию Cmake, необходимую для сборки данного проекта.
Значение 3.8 используется, поскольку соответствует версии Cmake, поставляемой в комплекте с Visual Studio 2019.
- `project(opengl C CXX)` - устанавливает имя проекта (далее его можно получить как значение переменной `${PROJECT_NAME}`
или `${CMAKE_PROJECT_NAME}`, если речь идёт о переменной project, заданной в корневой дирректории проекта),
а также используемые в нём языки (что позволяет принудительно подключить необходимые компиляторы), в данном проекте
автоматически выставляется только значение CXX, но поскольку некоторые статически подключаемые библиотеки написаны на C,
требуется вручную указать и его
- `add_subdirectory(proj1)` - позволяет добавить в список сборки цели (targets), определённые в проекте Cmake, расположенном в указанной папке
- `set(CMAKE_CXX_STANDARD 17)` принудительно устанавливает используемый стандарт C++
- `file(GLOB SHADERS shaders/*.vert shaders/*.frag)` - записывает в переменную `${SHADERS}` имена всех файлов, удовлетворяющих 
регулярному выражению `shaders/*.vert shaders/*.frag`
- `add_custom_target("${PROJECT_NAME}_shaders"
          COMMAND embed_shaders "${SHADERS}"
          BYPRODUCTS Shader.hpp
          WORKING_DIRECTORY "${PROJECT_SOURCE_DIR}"
          COMMENT "Generating embeded shaders"
          VERBATIM)` - создаёт новую цель сборки с именем `${PROJECT_NAME}_shaders`, выполняющую команду `embed_shaders "${SHADERS}"`
(в данном случае `embeded_shaders` является именем другого проекта Cmake, расположенным в папке `embeded`, поскольку Cmake видит это,
имя `embed_shaders` будет автоматически заменено на имя исполняемого файла, который получится в результате сборки этого проекта,
т.е. просто `embed_shaders` с случае Linux или MacOS или `embed_shaders.exe` в случае Windows), в результате которой будет
изменено содержимое файла `Shader.hpp`, при этом команду требуется выполнять из рабочей дирректории `"${PROJECT_SOURCE_DIR}"`
(значение этой переменной соответствует пути к данному `CMakeList.txt`, т.е. в случае `proj1/CMakeList.txt` в переменную
`${PROJECT_SOURCE_DIR}` будет записано значение `proj1`), `"Generating embeded shaders"` - сообщение, выводимое в процессе сборки
проекта и сигнализирующее о том, что сборка данной цели выполнена успешно, `VERBATIM` указывает, что значения переменных Cmake,
передаваемых на вход команде должны быть экранированы, т.е. в данном случае в команде `embed_shaders "${SHADERS}"` имена файлов в
переменной `${SHADERS}` будут заключены в двойные кавычки, что позволяет избежать проблем в случае, если пути к файлам будут содержать пробелы
- `if(MSVC) ... endif(MSVC)` - заключённый в этом блоке код будет выполнен только при компиляции с помощью Misrosoft Visual C++ compiler
- `set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /entry:mainCRTStartup")` - сообщает линковщику Visual Studio, что
точка входа в программы - это функция `main()`
- `add_executable("${PROJECT_NAME}" WIN32 "${SOURCES}")` - добавляет цель (target), с именем `${PROJECT_NAME}`, которая будет
собрана из файлов, перечисленных в значении переменной `${SOURCES}`, значение `WIN32` указывает, что в случае сборки проекта
на платформе Windows приложение должно быть оконным, а не консольным, проблема в данном случае в том, что оконные приложения в 
Windows имеют точку входа `WinMain()`, а нам требуется установить точку входа `main()`, что и делает предыдущая команда
- `add_dependencies("${PROJECT_NAME}" "${PROJECT_NAME}_shaders")` - сообщает, что цель с именем `"${PROJECT_NAME}"` требует
перед выполнением сборки цели с именем `"${PROJECT_NAME}_shaders"` (необходимо только для целей `add_custom_target`, т.к. по умолчанию
они не собираются, если от них никто не зависит)
- `target_include_directories("${PROJECT_NAME}" PRIVATE ../tinyobjloader)` - устанавливает что внутри проекта с именем `"${PROJECT_NAME}"`
и только внутри него (т.к. указан модификатор `PRIVATE`) будуд доступны зоголовочные файлы из папки `../tinyobjloader`, что необходимо
для вызова функций библиотек, определённых в этих заголовочных файлах
- `target_link_libraries("${PROJECT_NAME}" tinyobjloader)` - вызывает линковку цели `"${PROJECT_NAME}"` с библиотекой `tinyobjloader`
(статической или динамической, расширение файла и префикс `lib` в имени указывать не нужно, cmake определит корректное имя автоматически)
подулючённой ранее статически с помощью `add_subdirectory(../tinyobjloader "${PROJECT_BINARY_DIR}/tinyobjloader")` (в данном 
случае второй аргумент `"${PROJECT_BINARY_DIR}/tinyobjloader"` указывает папку, куда будет помещена скомпилированная статическая
библиотека для последующей линковки, этот аргумент необходимо указывать, т.к. путь к библиотеке начинается с `../`, в 
противном случае он будет определён автоматически) или другим путём
- `set(...)` устанавливает значения переменных и настроечных параметров (в данном случае все переменные настроены так, что
компилируется только необходимый минимум - статическая библиотека, все тесты, бенчмарки, динамические библиотеки и т.д. отключены)
- `file(COPY "resources/" DESTINATION "${PROJECT_BINARY_DIR}")` - копирует все файлы из папки `resources/` в папку 
`${PROJECT_BINARY_DIR}` (данная переменная хранит полный путь к папке, куда будет помещён готовый исполняемый файл)

### Общая идея
- в начале запускается программа `embed`, генерирующая на основе файлов в папке `shaders` зоголовочный файл
`Shader.hpp` (при изменении класса `Shader` будьте внимательны - не забудьте обновить исходный код `embed`), сожержащий
строковые константы вида `FRAG_FILE` для файлов вида `shaders/file.frag` (это сделано для того, чтобы можно было удобно
радактировать шейдеры в отдельном файле и использовать подсветку синтаксиса, которую реализуют дополнения для Visual Studio 
и других IDE)
- затем выполняется компиляция самой программы `proj1`, а также всех библиотек
- к `proj1` статичиски линкуются все библиотеки
- ресурсы из папки `resources` копируются в папку со свежескомпилированной программой (ВНИМАНИЕ! если папка resources
отсутствует - программа не будет успешно компилироваться), в результате чего в коде программы можно обращаться к ресурсам
не указывая полный путь к ним, а только лишь по имени

### Замечание
Процесс сборки устроен таким образом, что для добавления нового проекта достаточно сдублировать папку
`proj1` назвав её предположим `proj2`, затем в файле `proj2/CMakeLists.txt` заменить `project(${CMAKE_PROJECT_NAME}_proj1 C CXX)`
на `project(${CMAKE_PROJECT_NAME}_proj2 C CXX)`, добавить в корневой `CMakeLists.txt` строчку `add_subdirectory(proj2)`
и выбрать элемента запуска `proj2` вместо `proj1`. После этого можно изменять код, шейдеры и ресурсы `proj2` независимо от
`proj1` - все библиотеки уже будут подключены. ВНИМАНИЕ! при выполнении этой операции важно помнить, что папки `resources`
и `shaders` нельзя полностью удалять, т.к. это нарушит процесс борки, также важно, что класс `Shader` должен оставаться общим
для всех проектов, его нужно либо не трогать, либо изменить одинаково везде.

## Embed
Для компановки шейдеров используется дополнительная программа кодогенерации `embed`. Её задача - перед каждой сборкой обновлять
строковые константы, содержащие внутри себя шейдеры. Это сделано для того, чтобы у готовой программы было как можно меньше
внешних зависимостей. Таким образом, не требуется при каждом запуске вычитывать текст шейдеров из файлов и, с другой стороны,
сохраняется преимущество отдельного хранения шейдеров, что позволяет изменять эти файлы в редакторе с подсветкой синтаксиса.
Добавить подсветку синтаксиса в Visual Studio позволит например плагин
[GLSL language integration](https://marketplace.visualstudio.com/items?itemName=DanielScherzer.GLSL).
Если потребуется внести изменения в класс `Shader` необходимо соотвествующим образом обновить шапку (`header`)
в исходном коде `embed`. Кроме того, помните о том, что класс `Shader` должен быть общим для всех проектов в решении.
В результате работы этой программы файлы `*.vert` (вершинные шейдеры, описывающие вычисление координат вершин)
превращяются в константы `VERT_*`, а файлы `*.frag` (фрагментные шейдеры, описывающие вычисление цвета вершины) -
в константы `FRAG_`.

## OpenGL
В данном проекте используется OpenGL версии 3.3 или старше. Если вдруг потребуется использовать более новую версию
OpenGL (например версия 4.3 внесла много новой функциональности, например появилась возможность использовать OpenGL
просто для вычислений на видеоадаптере, для чего раньше требовалось знание языка Cuda или OpenCL), то необходимо изменить
её в нескольких местах:
- в файле `proj1/CMakeLists.txt` в строке `find_package(opengl 3.3 REQUIRED)`
- в файле `Window.cpp` строки `glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);` и
`glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);` содержат соответственно значения до и после точки в номере версии
- в каждом файле с шейдером в строке `#version 330 core` число `330` соответствует номеру версии без точки и с нулём на
конце.

### Класс Window
Класс Window используется для моздания окна и взаимодействия с пользовательским вводом посредством библиотеки GLFW.
Внутри класса содержится файловый дескриптор окна `GLFWwindow *window` и методы с ним взаимодействующие.
Конструктор принимает на вход три аргумента - адреса переменных, содержащих ширину и высоты будущего окна, а также строку
с названием, которое будет отображаться в шапке окна. Внутри конструктора происходит следующее:
- инициализируется библиотека GLFW
  - указывается минимальная требуемая версия библиотеки
  - указывается, что планируется к использованию профиль Core (в версии 3.0 OpenGL был сильно переработан, начиная с
  версии 3.1 старый код загружается под стандартным профилем Legacy, а для использования новых возможностей
  необходимо указывать, что требуемый профиль - Core, причём это требуется указывать в трёх местах - при создании окна,
  чтобы GLFW мог правильно его сконфигурировать, непосредственно создание контекста OpenGL, а так же в каждом файле шефдера)
  - указываем, что изначально окно не будет иметь возможности изменения размера
  - строка `glfwWindowHint(GLFW_SAMPLES, 4)` включает мультисемплинг уровня окна (далее нужно будет включить соответствующую
  настройку в OpenGL), что позволяет добиться некоторого сглаживания на стыках полигонов, параметр 4 указывает, 
  что каждое ребро будет 4 раза сдвинуто в разные случайно выбранные направления
  на расстояние меньше размера физического пикселя и результирующие цвета пикселей будут несколько скорректированы
- `glfwSwapInterval(1)` отвечает за вертикальную синхронизацию, буквально это означает, что перед фактическим отображением
новых цветов пикселей на экран каждый пиксель в буфере должен быть обновлён единожды (увеличение этого параметра внесёт
небольшую задержку в отрисовку, это позволяет косвенно влиять на частоту кадров, уменьшая её. значение 1 в докусентации
соответствует частоте 60 кадров в секунду, но фактическая частота кадров почему-то оказывается значительно выше) 
- далее происходит собственно создание окна с необходимыми настройками, если создать окно не получилось - вызывается
функция `errorOccurred`, обеспечивающая корректное освобождение ресурсов библиотеки GLFW перед завершением программы
- `glfwMakeContextCurrent` подготавливает контекст OpenGL для созданного ранее окна. здесь важным моментом является то,
что в нашей программе создаётся лишь один контекст (и одно соответствующее ему окно), технически возможно создание нескольких
контекстов и переключение между ними, для этого потребуется изменить настройки компиляции библиотек GLFW и GLEW в
`CMakeLists.txt` а также изучить документацию, т.к. код в этом случае может требовать значительной корректировки
- после создания контекста для OpenGL происходит инициализация библиотеки GLEW и загрузка адресов функций OpenGl, 
`glewExperimental = GL_TRUE` включает все экспериментальные возможности, т.к. используются стабильные версии
всех библиотек это приведёт только к тому, что некоторые внутренние алгоритмы OpenGl будут заменены на новые
более эффективные, никакой нестабильности в программу это не привносит
- после инициализации GLEW наконец появляется возможность использовать OpenGL, но его ещё требуется настроить
  - `glfwGetFramebufferSize` позволяет узнать фактический размер окна в пикселях, это необходимо, поскольку на экранах
  с большим разрешением операционные системы Windows 10 и MacOS используют хитрое масштабирование, в результате
  чего размера окна может внезапно оказаться больше (в случае Windows 10) или меньше (в случае MacOS) области, на
  которой можно производить отрисовку. данный вызов позволяет избежать проблем с этим (именно поэтому в конструктор
  требуется передавать ширину и высоту окна по адресу - их значения будут скорректированы в конструкторе и возвращены)
  - `glViewport` устанавливает размер и положение области отрисовки (используя координаты нижнего левого угла)
  - `glEnable(GL_DEPTH_TEST)` и `glEnable(GL_STENCIL_TEST)` нужны для перевода OpenGL в режим отрисовки 3D, т.к.
  изначально он рассчитан на рисование 2D фигур и некорректно обрабатывает отрисовку накладывающихся поверхностей
  - далее включается мультисемплинг, а также другие параметры OpenGL, отвечающие за сглаживание (это может замедлять
  работу программы практически не давая видимого эффекта, поэтому по умолчанию данные настройки отключены)
  - `glEnable(GL_BLEND)` и `glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)` устанавливают настройки OpenGl таким
  образом, что наконец появляется возможность корректно отрисовывать объекты с прозрачностью. здесь важно помнить, что для
  корректного вычисления финального цвета экранного пикселя в первую очередь необходимо отрисовывать непрозрачные объекты,
  а затем полупрозрачные в порядке от дальних к ближним (при отрисовке в другом порядке цвет будет вычисляться некорректро)
  
ВНИМАНИЕ! Изменение порядка функций в процессе инициализации может привести к получения неработоспособной программы.
На этом создание окна закончено. Тем не менее, в класс Window упакована вся требуемая функциональность GLFW, поэтому
для использования пользовательского ввода необходимо установить для окна обработчики ввода. Для этого существуют функции:
- SetWindowSizeCallback - вызывает переданную в него функцию при каждом изменении размеров окна (изначально окно не имеет
возможности изменения размера, но при установке обработчика параметры окна перенастраиваются так, что его размер станосится
изменяемым)
- SetKeyCallback - вызывается после нажатия любой кнопки на клавиатуре (а также её отпускании)
- SetMouseButtonCallback - вызывается при нажатии кнопок на мыши (поддерживается до 8 кнопок), если
потребуется обработка события прокрутки колёсика мыши - потребуется дополнительно реализовать функцию,
вызывающую glfwSetScrollCallback), фиксируются только нажатия мыши в момент, когда курсор находится поверх окна
- SetCursorPosCallback - вызывается при изменении положения курсора, кроме того, при данном вызове происходит
изменение порядка работы с курсором - `GLFW_CURSOR_NORMAL` говорит что курсор должен оставаться видимым и иметь
стандартный вид, другие параметры позволяют изменить форму курсора (даже загрузить своё изображение размером до 16x16
пикселей) или полностью скрыть курсор, чтобы создать ощущение шутера (например наложив вместо этого картинку прицела в 
центре экрана)
Важно помнить, что это не все доступные события пользовательского ввода, другие события и их обработчики можно найти
[здесь](https://www.glfw.org/docs/latest/input_guide.html).

После создания окна, установки всех callback-ов и формирования всех объектов для отрисовки необходимо вызвать
функцию Loop, инициирующую бесконечный цикл отрисовки, который будет продолжаться до закрытия программы.
Функция отрисовки получает на вход текущее время, а также время отрисовки последнего кадра - эти данные нужны для
плавного и равномерного анимирования сцены.
Внутри функции Loop `glfwPollEvents` обрабатывает все события пользовательского ввода, скопившиеся с момента предыдущей
проверки их очереди, выполняет перерисовку сцены и затем вызовом `glfwSwapBuffers` инициирует перерисовку окна на экране
(если конечно значение вертикальной синхронизации не вынуждает окно ожижать доволнительных перерисовок, это, как было
упомянуто, может использоваться для искусственного снижения частоты кадров, а так же для хитрой перерисовки, не требующей
предварительного освобождения экранного буфера предыщудего кадра, что в данной программе не используется).

После установки флага о закрытии окна и установки соответствующего флага `glfwWindowShouldClose` цикл перерисовки
прекращается и вызов `Destroy` освобождает ресурсы окна и библиотек GLEW и GLFW.


